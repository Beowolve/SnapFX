package org.snapfx.model;

import javafx.beans.property.*;
import javafx.scene.Node;
import javafx.scene.image.Image;

import java.util.UUID;

/**
 * Wrapper class for a dockable JavaFX node.
 * Encapsulates a JavaFX Node with metadata such as title and ID.
 *
 * <p>Uses two types of IDs:</p>
 * <ul>
 *   <li><b>dockNodeId</b>: Type-based identifier used by the factory to create nodes (e.g., "editor", "console")</li>
 *   <li><b>layoutId</b>: Unique identifier for this specific instance in the layout (managed by framework)</li>
 * </ul>
 */
public class DockNode implements DockElement {
    /**
     * Defines where a hidden node should be restored.
     */
    public enum HiddenRestoreTarget {
        /** Restore into docked layout. */
        DOCKED,
        /** Restore into floating layout. */
        FLOATING
    }

    private final String dockNodeId; // Type-based ID for factory
    private String layoutId; // Unique ID for this instance in layout
    private final StringProperty title;
    private final ObjectProperty<Node> content;
    private final ObjectProperty<Image> icon;
    private final BooleanProperty closeable;
    private DockContainer parent;

    // Store last known position for restore
    private DockElement lastKnownTarget;
    private DockPosition lastKnownPosition;
    private Integer lastKnownTabIndex;
    private Double lastFloatingX;
    private Double lastFloatingY;
    private Double lastFloatingWidth;
    private Double lastFloatingHeight;
    private Boolean lastFloatingAlwaysOnTop;
    private HiddenRestoreTarget hiddenRestoreTarget = HiddenRestoreTarget.DOCKED;

    /**
     * Creates a DockNode with an auto-generated UUID as both dockNodeId and layoutId.
     * Note: UUIDs change between sessions, making persistence unreliable.
     * For proper save/load support, use the constructor with a custom dockNodeId.
     *
     * @param content JavaFX content node
     * @param title node title
     */
    public DockNode(Node content, String title) {
        this(UUID.randomUUID().toString(), content, title);
    }

    /**
     * Creates a DockNode with a custom dockNodeId.
     * Use this constructor for nodes that need to be persisted across sessions.
     * The layoutId will be auto-generated by the framework when added to the layout.
     *
     * @param dockNodeId Type-based identifier for this node (e.g., "editor", "console", "projectExplorer")
     * @param content The JavaFX node to display
     * @param title The title shown in headers and tabs
     */
    public DockNode(String dockNodeId, Node content, String title) {
        this.dockNodeId = dockNodeId;
        this.layoutId = null; // Will be set by framework when added to layout
        this.content = new SimpleObjectProperty<>(content);
        this.title = new SimpleStringProperty(title);
        this.icon = new SimpleObjectProperty<>(null);
        this.closeable = new SimpleBooleanProperty(true);
    }

    // Getters

    /**
     * Returns the unique layout ID for this node instance.
     * This ID is used for positioning in the layout structure.
     * It is automatically generated by the framework when the node is added to a layout.
     */
    public String getId() {
        return layoutId;
    }

    /**
     * Returns the type-based dockNodeId used by the factory.
     * This ID identifies the type of node (e.g., "editor", "console").
     *
     * @return type-based dock-node ID
     */
    public String getDockNodeId() {
        return dockNodeId;
    }

    /**
     * Sets the unique layout ID for this node instance.
     * This is called by the framework when the node is added to a layout.
     *
     * @param layoutId unique layout instance ID
     */
    public void setLayoutId(String layoutId) {
        this.layoutId = layoutId;
    }

    public String getTitle() {
        return title.get();
    }

    /**
     * Returns the observable title property.
     *
     * @return title property
     */
    public StringProperty titleProperty() {
        return title;
    }

    public void setTitle(String title) {
        this.title.set(title);
    }

    public Node getContent() {
        return content.get();
    }

    /**
     * Returns the observable content property.
     *
     * @return content property
     */
    public ObjectProperty<Node> contentProperty() {
        return content;
    }

    public void setContent(Node content) {
        this.content.set(content);
    }

    public Image getIcon() {
        return icon.get();
    }

    /**
     * Returns the observable icon property.
     *
     * @return icon property
     */
    public ObjectProperty<Image> iconProperty() {
        return icon;
    }

    public void setIcon(Image icon) {
        this.icon.set(icon);
    }

    public boolean isCloseable() {
        return closeable.get();
    }

    /**
     * Returns the observable closeable property.
     *
     * @return closeable property
     */
    public BooleanProperty closeableProperty() {
        return closeable;
    }

    public void setCloseable(boolean closeable) {
        this.closeable.set(closeable);
    }

    @Override
    public DockContainer getParent() {
        return parent;
    }

    @Override
    public void setParent(DockContainer parent) {
        this.parent = parent;
    }

    /**
     * Returns the remembered restore target element used for hidden/sidebar/floating restore flows.
     *
     * @return last known target element, or {@code null}
     */
    public DockElement getLastKnownTarget() {
        return lastKnownTarget;
    }

    /**
     * Sets the remembered restore target element.
     *
     * @param lastKnownTarget remembered target element, or {@code null}
     */
    public void setLastKnownTarget(DockElement lastKnownTarget) {
        this.lastKnownTarget = lastKnownTarget;
    }

    /**
     * Returns the remembered restore dock position.
     *
     * @return last known dock position, or {@code null}
     */
    public DockPosition getLastKnownPosition() {
        return lastKnownPosition;
    }

    /**
     * Sets the remembered restore dock position.
     *
     * @param lastKnownPosition remembered dock position, or {@code null}
     */
    public void setLastKnownPosition(DockPosition lastKnownPosition) {
        this.lastKnownPosition = lastKnownPosition;
    }

    /**
     * Returns the remembered tab index for center/tab restores.
     *
     * @return last known tab index, or {@code null}
     */
    public Integer getLastKnownTabIndex() {
        return lastKnownTabIndex;
    }

    /**
     * Sets the remembered tab index for center/tab restores.
     *
     * @param lastKnownTabIndex remembered tab index, or {@code null}
     */
    public void setLastKnownTabIndex(Integer lastKnownTabIndex) {
        this.lastKnownTabIndex = lastKnownTabIndex;
    }

    /**
     * Returns the remembered floating x-position.
     *
     * @return last known floating x-position, or {@code null}
     */
    public Double getLastFloatingX() {
        return lastFloatingX;
    }

    /**
     * Sets the remembered floating x-position.
     *
     * @param lastFloatingX floating x-position, or {@code null}
     */
    public void setLastFloatingX(Double lastFloatingX) {
        this.lastFloatingX = lastFloatingX;
    }

    /**
     * Returns the remembered floating y-position.
     *
     * @return last known floating y-position, or {@code null}
     */
    public Double getLastFloatingY() {
        return lastFloatingY;
    }

    /**
     * Sets the remembered floating y-position.
     *
     * @param lastFloatingY floating y-position, or {@code null}
     */
    public void setLastFloatingY(Double lastFloatingY) {
        this.lastFloatingY = lastFloatingY;
    }

    /**
     * Returns the remembered floating width.
     *
     * @return last known floating width, or {@code null}
     */
    public Double getLastFloatingWidth() {
        return lastFloatingWidth;
    }

    /**
     * Sets the remembered floating width.
     *
     * @param lastFloatingWidth floating width, or {@code null}
     */
    public void setLastFloatingWidth(Double lastFloatingWidth) {
        this.lastFloatingWidth = lastFloatingWidth;
    }

    /**
     * Returns the remembered floating height.
     *
     * @return last known floating height, or {@code null}
     */
    public Double getLastFloatingHeight() {
        return lastFloatingHeight;
    }

    /**
     * Sets the remembered floating height.
     *
     * @param lastFloatingHeight floating height, or {@code null}
     */
    public void setLastFloatingHeight(Double lastFloatingHeight) {
        this.lastFloatingHeight = lastFloatingHeight;
    }

    /**
     * Returns the last known floating always-on-top state for this node.
     *
     * @return last known always-on-top state, or {@code null}
     */
    public Boolean getLastFloatingAlwaysOnTop() {
        return lastFloatingAlwaysOnTop;
    }

    /**
     * Sets the last known floating always-on-top state for this node.
     *
     * @param lastFloatingAlwaysOnTop remembered always-on-top state, or {@code null}
     */
    public void setLastFloatingAlwaysOnTop(Boolean lastFloatingAlwaysOnTop) {
        this.lastFloatingAlwaysOnTop = lastFloatingAlwaysOnTop;
    }

    /**
     * Returns where this hidden node should be restored.
     *
     * @return hidden restore target
     */
    public HiddenRestoreTarget getHiddenRestoreTarget() {
        return hiddenRestoreTarget;
    }

    /**
     * Sets where this hidden node should be restored.
     *
     * @param hiddenRestoreTarget hidden restore target, defaults to {@link HiddenRestoreTarget#DOCKED} when {@code null}
     */
    public void setHiddenRestoreTarget(HiddenRestoreTarget hiddenRestoreTarget) {
        this.hiddenRestoreTarget = hiddenRestoreTarget == null ? HiddenRestoreTarget.DOCKED : hiddenRestoreTarget;
    }

    @Override
    public String toString() {
        return "DockNode{layoutId='" + getId() + "', dockNodeId='" + dockNodeId + "', title='" + title.get() + "'}";
    }
}
